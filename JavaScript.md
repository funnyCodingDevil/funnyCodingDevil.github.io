# JavaScript

1. 计算机语言分为: 机器语言，编程语言(汇编语言和**高级语言**)
2. 汇编语言作为高级语言与机器语言交流的翻译器
3. 编程语言和标记语言的区别在于
   1. 编辑语言有很强的行为逻辑（js），(主动向计算机发送命令)
   2. 标记语言仅被用来被读取(html，css)，(被动)
4. js是脚本语言，由上往下逐行执行
5. js的常见用法：
   1. 实现一些业务逻辑（如表单验证）
   2. 网页上的特效
   3. 制作脚本
6. HTML/CSS/JS的关系
   1. html/CSS 是标记语言，决定了网页的结构和显示内容
   2. js 是脚本编程语言，实现业务逻辑和页面控制，决定了功能，实现了动作
7. 渲染引擎和js引擎
   1.  渲染引擎渲染html，css标记语言
   2.  js引擎读取js文件代码
8. js的3大组成
   1. ECMAScript
   2. DOM(页面文档模型)
   3. BOM(浏览器对象模型)

### 变量小结

输入输出语句

| 方法                 | 说明                           | 归属   |
| -------------------- | ------------------------------ | ------ |
| alert(msg)           | 浏览器弹出警示框               | 浏览器 |
| **console.log(msg)** | 浏览器控制台打印输出信息       | 浏览器 |
| prompt(info)         | 浏览器弹出输入框，用户可以输入 | 浏览器 |

为什么需要变量：需要保存数据

变量是什么：是储存数据的容器，方便以后使用里面的数据

变量的本质：内存里的一块空间，用来存储数据

变量什么使用：先声明变量，然后赋值，声明变量的本质是去内存申请空间

变量的初始化：声明变量并赋值我们称之为变量的初始化

变量的命名规范：驼峰命名法；区分那些命名不合法

| 规则                                                         |
| ------------------------------------------------------------ |
| 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name |
| 严格区分大小写。var app; 和 var App; 是两个变量              |
| 不能 以数字开头。  18age   是错误的                          |
| 不能 是关键字、保留字。例如：var、for、while                 |
| 变量名必须有意义。 MMD   BBD        nl   →     age           |
| 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName |

交换2个变量的值：使用一个临时变量 把1中的值给临时变量，再将2中的值给1，最后把临时变量的值给2

### 数据类型

| 简单数据类型  | 说明                                                  |
| ------------- | ----------------------------------------------------- |
| **Number**    | 数字型， 包含整型值和浮点型值，如：21、0.21           |
| **Boolean**   | 布尔值，如true、false，等价于1和0                     |
| **String**    | 字符串类型，如“张三”，注意js中，字符串都带`‘’ ""`     |
| **Undefined** | `var a;`声明了变量a但没有给值，此时`a = undefined`    |
| **Null**      | `var a = null;`声明了变量a为空值                      |
| *Symbol       | `Symbol('key')`用解决属性名冲突的问题                 |
| *BigInt       | `BigInt("9007199254740995");`可以安全存储和操作大整数 |

#### 运算符

**运算符**（operator）也被称为**操作符**，是用于实现赋值、比较和执行算数运算等功能的符号。

JavaScript中常用的运算符有：

- 算数运算符
- 递增和递减运算符
- 比较运算符
- 逻辑运算符
- 赋值运算符

算数运算符中        // 通过判断余数是否为0 可以判断是否能被整除

递增和递减运算符 // 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。

- 前置递增（递减）运算符 先自加（减） 后返回值
- 后置递增（递减）运算符 先返回原值，后自加

#### 逻辑运算符

概念:逻辑运算符是用来进行布尔值运算的运算符,其返回值也是布尔值。后面开发中经常用于多个条件的判断

逻辑与/或的实际返回值,是逻辑运算语句中停止运算时所在的表达式的返回值

逻辑与&&

两边都是 true才返回 true，否则返回 false

逻辑或 ||

两边都是 false才返回 false，否则返回 true

换句话说，只要判断中有一个是true，那结果就是true

逻辑非 !

<font color='red'>短路运算（逻辑中断）（★★★★★ - 常用且非常重要）</font>

- 短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;

  - 逻辑与

    - 语法： 表达式1 && 表达式2

  - ```
    - 如果第一个表达式的值为真，则返回表达式2
    
    - 如果第一个表达式的值为假，则返回表达式1
    ```

  - 逻辑或

    - 语法： 表达式1 || 表达式2

  - ```
    - 如果第一个表达式的值为真，则返回表达式1
    - 如果第一个表达式的值为假，则返回表达式2
    ```



### 流程控制

流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。

##### 分支流程控制

if 语句、switch 语句

if 语句执行思路：  如果 if 里面的条件表达式结果为真 true 则执行大括号里面的 执行语句, 如果if 条件表达式结果为假 则不执行大括号里面的语句 则执行if 语句后面的代码

if else语句执行思路: 如果表达式结果为真 那么执行语句1  否则  执行语句2

if else if 语句(多分支语句)(★★★★★)

**<font color='red'>执行思路</font>**

利用多个条件来选择不同的语句执行 得到不同的结果  多选1 的过程

如果条件表达式1 满足就执行 语句1, 执行完毕后，退出整个if 分支语句  

如果条件表达式1 不满足，则判断条件表达式2 , 满足的话，执行语句2 以此类推

如果上面的所有条件表达式都不成立，则执行else 里面的语句

##### 三元表达式

- 语法结构

  ```js
  条件表达式1 ? 表达式2 : 表达式3;
  ```

- 执行思路
  - 如果条件表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值
  - 简单理解： 就类似于  if  else （双分支） 的简写

##### switch分支流程控制(★★★★★)

语法结构

switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的**<font color='red'>特定值</font>**的选项时，就可以使用 switch。

<font color='red'>执行思路: </font> 利用我们的表达式的值 和 case 后面的选项值相匹配 如果匹配上，就执行该case 里面的语句  如果都没有匹配上，那么执行 default里面的语句

- switch ：开关 转换  ， case ：  选项

- 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量

- 关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号

- switch 表达式的值会与结构中的 case 的值做比较 

- 如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束

- 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码

  **注意：执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。且无论是否满足下一个case的条件**

##### switch 语句和 if else if 语句的区别(★★★)

- 一般情况下，它们两个语句可以相互替换
- switch...case 语句通常处理 case为比较**确定值**的情况， if…else…语句常用于**范围判断**(大于、等于某个范围)
- switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。
  - 当分支比较少时，if… else语句的执行效率比 switch语句高。
  - 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。 

### for循环小结

- for 循环可以重复执行某些相同代码
- 通过计数器，for 循环可以重复执行些许不同的代码
- for 循环也可以重复执行某些数学操作，比如算术运算符加法操作
- 随着需求增加，双重for循环可以做更多的效果
- 双重 for 循环，外层循环一次，内层 for 循环全部执行（n ^ m）
- for 循环是循环条件和数字直接相关的循环

### while循环小结

while 语句可以在条件**表达式为真**的前提下，**循环执行**指定的一段代码，直到表达式不为真时结束循环

**执行思路**：

1. 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码
2. 执行循环体代码
3. 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束

**注意**：

1. 使用 while 循环时一定要注意，它**必须要有退出条件，否则会成为死循环**（电脑会卡死的哟~~）
2. while 循环和 for 循环的不同之处在于 **while 循环可以做较为复杂的条件判断（是否确定循环次数）**



### 循环总结(★★★★★)

如何选择循环语句？

1. 确定循环次数

   for: 循环条件一般是一个范围

2. 不确定循环次数 或 循环条件可以比较复杂

   while： 先判断，再做 do-while：先做，再判断（先执行一次，才知道是否要开始循环）

3. 大部分情况用的都是for; 而while应用场景是：结合break属性，写死循环逻辑

### 数组

概念:数组是一组数据的集合,其中每个数据都没被称为元素

特点:可以存放任意类型元素,数据集合

创建数组:

1. 字面量 var arr = [ ]
2. new 创建 var 数组名 = new Array()

获取数组中的元素

- 索引(下标) : 用来访问数组元素的序号 从0开始 arr[0]
- 特点  
  - 数组可以通过索引来访问, 设置, 修改对应的数组元素
  - 可以通过 数组名[索引] 的方式来获取数组中的元素

- 如果访问时数组没有和索引值对应的元素 得到的是undefined

##### 遍历数组

- 把数组中的元素从头到尾访问(获取)一遍

- 特点

  - 数组的长度: 默认情况下表示数组元素的个数 数组名.length
  - 数组元素变化,长度会跟着变化
  - length可以被修改

- 写法 

  ```js
  for (var i = 0; i < arr.length; i++) {
      console.log(arr[i])
  }
  ```

- 数组中新增元素

  - 修改数组长度来达到新增元素的效果 arr[arr.length] = 新数据
  - 修改索引号的方法 arr[x] = '元素'  如果是已存在的索引新元素会覆盖

- 注意 : 如果直接给数组赋值,数据类型就会改变,原来声明的数组内容就不在了

##### 数组的应用

1. 筛选数组

   ```
   // 将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。
   var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
   var newArr = []
   for (var i = 0; i < arr.length; i++) {
       if (arr[i] >= 10) {
       	newArr[newArr.length] = arr[i]
       }
   }
   console.log(newArr)
   ```

2. 数组去重

   ```
   // 将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数组。
   var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
   var newArr = []
   for (var i = 0; i < arr.length; i++) {
       if (arr[i] != 0) {
       	newArr[newArr.length] = arr[i]
       }
   }
   console.log(newArr)
   // 将数组中所有的重复元素都给去掉
   var newArr = []
   for (var i = 0; i < arr.length; i++) {
       var isRepetition = false // 用布尔值确定arr当前索引下的元素在新数组中是否有重复的
       if (newArr[i] === arr[i]) {
           isRepetition = true  // 如果有重复的就标记为真然后退出循环
           break
       }
       // 如果元素不重复 就添加到新数组中 
       if (isRepetition !== true) {
       	newArr[newArr.length] = arr[i]
       }
   }
   console.log(newArr)
   ```

3. 翻转数组 (后续使用 reverse() )

   ```
   // 将数组 ['red', 'green', 'blue', 'pink', 'purple'] 的内容反过来存放
   /* 1、声明一个新数组 newArr
      2、把旧数组索引号第4个取过来(arr.length - 1)，给新数组索引号第0个元素 (newArr.length)
      3、我们采取 递减的方式  i-- */
   var arr = ['red', 'green', 'blue', 'pink', 'purple'] 
   var newArr = []
   for (var i = arr.length - 1; i >= 0; i--) {
       newArr[newArr.length] = arr[i]
   }
   console.log(newArr)
   ```

4. 冒泡排序

   是一种算法，把一系列的数据按照一定的顺序进行排列显示(**从小到大或从大到小**）。

   ```
   var arr = [1,241,534,7346,8,7,12] 从小到大排列
   for (var i = 0; i < arr.length - 1; i++) { // 外层循环控制趟数
   	// i 循环的次数是长度-1 最后一次循环是多余的
       for (var j = 0; j < arr.length - 1 - i; i++) { 
       	// 里层循环是每一趟的交换次数
   		// j 循环的次数是长度 -1 再 - i 
           if (arr[j] < arr[j + 1]) {
           //如果j小于j+1 那么进入循环 
           	var temp = arr[j] // 声明一个临时变量 存放数据
           	arr[j] = arr[j + 1] // 把大的值存进arr[j]
           	arr[j + 1] = temp
       }
   }
   console.log(arr)
   ```

### 函数

#### 概念

- 封装了一段可以被重复调用执行的代码块,通过代码块能实现大量代码的重复使用

- 注意:  函数就是方法 可以理解成一个工具。


面向对象的三大特征：封装，继承，多态

继承：可以使用现有的类的所有功能，并无需重新编写原来的类的情况下对这些功能进行扩展。

多态（polymorphisn）：允许你讲父对象设置成和一个或多个他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性以不同的方式运作，简单的说，就是允许将子类类型的指针赋值给父类类型的指针。

```js
// 声明函数
// 语法
function 函数名 () {
    // 函数体代码
}
注意：function需要小写 函数不调用，自身不执行
// 调用函数
函数名() // 函数名后记得带括号
```

##### 函数的封装

- 把一个或者多个功能通过函数封装起来，对外只提供一个简单的函数接口
- 函数将功能封装好，调用者就不需要关心内部是如何实现的

##### 函数的参数

```js
// 带参数的函数声明
function 函数名 (形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔，是未知的参数
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...) // 调用时需要传入相应的参数,函数调用时传入的真实数据
```

参数的作用 ：在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去

参数作用理解：将函数写死，内容写活，让函数功能更加强大，更加灵活

1. 函数调用的时候实参值会传递给形参
2. 形参简单理解为：不用声明的变量

函数形参和实参个数匹配问题
- 实参个数等于形参个数：输出正确结果

- 实参个数多余形参个数：只取新参的个数

- 实参个数小于形参个数：多出来的形参定义为undefined

函数的返回值

通过return语句，将值返回给调用者

**特点：**

1. 在使用 return 语句时，函数会停止执行，并返回指定的值，之后的代码不会执行
2. 如果函数没有 return ，默认返回的值是 undefined
3. **return的作用**：将函数写死内容写活，让函数功能更加强大，更加灵活
4. 只能返回一个值，返回多个值的时候，以最后一个为准

函数中break，continue，return的区别

- break ：结束当前的循环体（如 for、while）
- continue ：跳出本次循环，继续执行下次循环（如 for、while）
- return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码

##### arguments

1. 在 JavaScript 中，arguments 实际上它是当前函数的一个**内置对象**。
2. 当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的**所有实参**。
3. arguments展示形式是一个**伪数组**，因此可以进行遍历。(伪数组不是数组！它只是具有数组的部分特点)
4. 伪数组具有以下特点：
   - 具有 length 属性
   - 按索引方式储存数据，但不具有数组的 push , pop 等方法

应用场景：我们的函数允许用户调用时，传递不定长（不确定个数）的参数，函数声明时，不会使用形参，而是使用arguments

函数的两种声明方式

```js
自定义函数方式(命名函数)
	function fn () {...}
// 调用  
fn(); 
函数表达式方式(匿名函数）
	var fn = function () {...}
// 调用的方式，函数调用必须写到函数体下面
fn();
```

### 作用域

简单来说就是代码的有效范围

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。

##### 特点

- 作用域的使用提高了程序逻辑的局部性
- 增强了程序的可靠性
- 减少了命名冲突

作用域分类：

- 全局作用域
- 局部作用域（函数作用域）
- 块级作用域（用let/const定义变量时，）

##### 变量的作用域

全局变量

1. 可以在代码的任意位置使用
2. 全局作用域下用var声明的变量
3. 特殊情况下在函数内不使用var声明的变量也是全局变量（隐式全局）

局部变量

1. 只能在函数内部使用的
2. 在函数内用var声明的变量
3. 函数的形参实际上就是局部变量
4. 函数运行结束后，就回被销毁，节省内存空间

作用域链

函数嵌套函数，作用域中有作用域，形成作用域链。

写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中 （采用就近原则）

##### 声明提升

1. JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。
2. JavaScript 解析器在运行 JavaScript 代码的时候分为两步：**声明提升(预解析)**和**代码执行**。
3. **声明提升(预解析)：**在当前作用域下, JS 代码执行之前，浏览器会默认把带有 `var` 和 `function` 声明的变量在内存中进行提前声明或者定义
   - **其实相当于提前读一遍代码，找`var，function`，将变量和函数声明进行提升**
4. 代码执行： 从上到下执行JS语句

###### 变量的声明提示

**变量声明提升（变量预解析）：** 变量的声明会被提升到**当前作用域的最上面**，**变量的赋值不会提升**

###### 函数声明提升

**函数声明提升（函数预解析）：** 函数的声明会被提升到**当前作用域的最上面**，但是不会调用函数

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！

###### 函数表达式声明函数问题

函数表达式创建函数，会执行变量提升（因为是var关键字）

### 对象（字典）

##### 概念

- 是一组无序的相关属性和方法的集合（可以存放任意类型的元素），简单理解就是一本字典，想查什么就去翻字典，万物皆对象（字符串，数值，数组，函数等）
- 对象是由属性和方法组成的

  - 属性：事物的特征（名词）
  - 方法：事物的方法（动词）  

##### 创建对象的方法

- ###### 利用字面量创建对象

  ```js
  var obj = {
      key: value,
      key2: value2,
  }
  ```

  - 对象的调用和访问
    - 对象.属性
    - 对象[''属性]
    - 对象.方法()
    - 对象['方法']()

- ###### 利用new Object 创建对象

  - var andy = new Object();
  - 通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象
  - Object() ：第一个字母大写   
  - new Object() ：需要 new 关键字
  - 使用的格式：对象.属性 = 值;     

- ###### 利用构造函数创建对象

  - 创建对象的方法 - 把对象里面一些相同的属性和方法抽象出来封装到函数里面

    ```js
    function 构造函数名(形参1, 形参2, 形参3..) {
        // 构造函数的形参和对象的普通属性是一致的
        this.属性名1 = 形参1 // 形参就是给属性赋值
        this.属性名2 = 形参2
        this.属性名3 = 形参3
        this.方法名 = function () {} // 函数体不需要传递
    }
    // 调用方法
    var obj = new 构造函数名(实参1，实参2，实参3)
    ```

  - 注意：
    	1.   构造函数约定首字母大写。
    	2.   函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。
    	3.   构造函数中不需要 return 返回结果。
    	4.   当我们创建对象的时候，必须用 new 来调用构造函数。
  - 构造函数和对象的区别
    - 构造函数
      - 如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）
    - 创建对象
      - 如 new Stars()，特指某一个（具体的某一个），通过 new 关键字创建对象的过程我们也称为对象实例化
      - 实例
        - 就是实际的例子
        - 对象又叫做实例

##### new 关键字的执行过程

```js
// 1.在构造函数代码执行之前,创建一个空对象
var temp = new Object() // 实际上是堆中对应的地址
// 2.修改this的指向 ,把this指向创建出来的空对象
temp = this
// 3.执行函数的代码

// 4.函数执行完成后,返回this --- 即创建出来的对象

```

##### 遍历对象

> for...in 语句用于对数组或者对象的属性进行循环操作。
>
> **理解**：遍历obj对象中的所有属性名k，然后我们可以根据属性名k获取属性值

- 语法

  ```js
  for (变量 in 对象名字) {
      // 在此执行代码
  }
  ```

- 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。







